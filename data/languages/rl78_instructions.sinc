
#
# Table 1/30
#

# MOV r, #byte
:MOV DREG_BYTE, "#"data is SKIP_CHECK & op_h=0x5 & DREG_BYTE; data {
    build SKIP_CHECK;
    DREG_BYTE = data;
}

# MOV r, A
:MOV DREG_BYTE, A is SKIP_CHECK & op_h=0x7 & A & DREG_BYTE & dreg_byte!=1 {
    build SKIP_CHECK;
    DREG_BYTE = A;
}

# MOV A, r
:MOV A, DREG_BYTE is SKIP_CHECK & op_h=0x6 & A & DREG_BYTE & dreg_byte!=1 {
    build SKIP_CHECK;
    A = DREG_BYTE;
}

# MOV saddr, #byte
:MOV saddr, "#"data is SKIP_CHECK & opcode=0xCD; saddr; data {
    build SKIP_CHECK;
    saddr = data;
}

# MOV sfr, #byte
:MOV sfr_byte, "#"data is SKIP_CHECK & opcode=0xCE; sfr_byte; data {
    build SKIP_CHECK;
    sfr_byte = data;
}

# MOV !addr16, #byte
:MOV addr16, "#"data is SKIP_CHECK & opcode=0xCF; addr16; data {
    build SKIP_CHECK;
    addr16 = data;
}

# MOV A, saddr
:MOV A, saddr is SKIP_CHECK & opcode=0x8D & A; saddr {
    build SKIP_CHECK;
    A = saddr;
}

# MOV saddr, A
:MOV saddr, A is SKIP_CHECK & opcode=0x9D & A; saddr {
    build SKIP_CHECK;
    saddr = A;
}

# MOV A, sfr
:MOV A, sfrp is SKIP_CHECK & opcode=0x8E & A; sfrp {
    build SKIP_CHECK;
    A = sfrp;
}

# MOV sfr, A
:MOV sfrp, A is SKIP_CHECK & opcode=0x9E & A; sfrp {
    build SKIP_CHECK;
    sfrp = A;
}

# MOV A, !addr16
:MOV A, addr16 is SKIP_CHECK & opcode=0x8F & A; addr16 {
    build SKIP_CHECK;
    A = addr16;
}

# MOV !addr16, A
:MOV addr16, A is SKIP_CHECK & opcode=0x9F & A; addr16 {
    build SKIP_CHECK;
    addr16 = A;
}

# MOV PSW, #byte
:MOV PSW, "#"data is SKIP_CHECK & opcode=0x9F & PSW; opcode=0xFA; data {
    build SKIP_CHECK;
    PSW = data;
}

# MOV A, PSW
:MOV A, PSW is SKIP_CHECK & opcode=0x8E & A & PSW; opcode=0xFA {
    build SKIP_CHECK;
    A = PSW;
}

# MOV PSW, A
:MOV PSW, A is SKIP_CHECK & opcode=0x9E & A & PSW; opcode=0xFA {
    build SKIP_CHECK;
    PSW = A;
}

# MOV ES, #byte
:MOV ES, "#"data is SKIP_CHECK & opcode=0x41 & ES; data {
    build SKIP_CHECK;
    ES = data;
}

# MOV ES, saddr
:MOV ES, saddr is SKIP_CHECK & opcode=0x61 & ES; opcode=0xB8; saddr {
    build SKIP_CHECK;
    ES = saddr;
}

# MOV A, ES
:MOV A, ES is SKIP_CHECK & opcode=0x8E & A & ES; opcode=0xFD {
    build SKIP_CHECK;
    A = ES;
}

# MOV ES = A
:MOV ES, A is SKIP_CHECK & opcode=0x9E & A & ES; opcode=0xFD {
    build SKIP_CHECK;
    ES = A;
}

# MOV CS, #byte
:MOV CS, "#"data is SKIP_CHECK & opcode=0xCE & CS; opcode=0xFC; data {
    build SKIP_CHECK;
    CS = data;
}

#
# Table 2/30
#

# MOV A, CS
:MOV A, CS is SKIP_CHECK & opcode=0x8E & A & CS; opcode=0xFC {
    build SKIP_CHECK;
    A = CS;
}

# MOV CS, A
:MOV CS, A is SKIP_CHECK & opcode=0x9E & A & CS; opcode=0xFC {
    build SKIP_CHECK;
    CS = A;
}

# MOV A, [DE]
:MOV A, AddrDE is SKIP_CHECK & opcode=0x89 & A & AddrDE {
    build SKIP_CHECK;
    A = AddrDE;
}

# MOV [DE], A
:MOV AddrDE, A is SKIP_CHECK & opcode=0x99 & A & AddrDE {
    build SKIP_CHECK;
    AddrDE = A;
}

# MOV [DE+byte], #byte
:MOV AddrDEOffset, "#"data is SKIP_CHECK & opcode=0xCA; AddrDEOffset; data {
    build SKIP_CHECK;
    AddrDEOffset = data;
}

# MOV A, [DE+byte]
:MOV A, AddrDEOffset is SKIP_CHECK & opcode=0x8A & A; AddrDEOffset {
    build SKIP_CHECK;
    A = AddrDEOffset;
}

# MOV [DE+byte], A
:MOV AddrDEOffset, A is SKIP_CHECK & opcode=0x9A & A; AddrDEOffset {
    build SKIP_CHECK;
    AddrDEOffset = A;
}

# MOV A, [HL]
:MOV A, AddrHL is SKIP_CHECK & opcode=0x8B & A & AddrHL {
    build SKIP_CHECK;
    A = AddrHL;
}

# MOV [HL], A
:MOV AddrHL, A is SKIP_CHECK & opcode=0x9B & A & AddrHL {
    build SKIP_CHECK;
    AddrHL = A;
}

# MOV [HL+byte], #byte
:MOV AddrHLOffset, u8 is SKIP_CHECK & opcode=0xCC; AddrHLOffset; u8 {
    build SKIP_CHECK;
    AddrHLOffset = u8;
}

# MOV A, [HL+byte]
:MOV A, AddrHLOffset is SKIP_CHECK & opcode=0x8C & A; AddrHLOffset {
    build SKIP_CHECK;
    A = AddrHLOffset;
}

# MOV [HL+byte], A
:MOV AddrHLOffset, A is SKIP_CHECK & opcode=0x9C & A; AddrHLOffset {
    build SKIP_CHECK;
    AddrHLOffset = A;
}

# MOV A, [HL+B]
:MOV A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0xC9 & AddrHLOffsetB {
    build SKIP_CHECK;
    A = AddrHLOffsetB;
}

# MOV [HL+B], A
:MOV AddrHLOffsetB, A is SKIP_CHECK & opcode=0x61 & A; opcode=0xD9 & AddrHLOffsetB {
    build SKIP_CHECK;
    AddrHLOffsetB = A;
}

# MOV A, [HL+C]
:MOV A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0xE9 & AddrHLOffsetC {
    build SKIP_CHECK;
    A = AddrHLOffsetC;
}

# MOV [HL+C], A
:MOV AddrHLOffsetC, A is SKIP_CHECK & opcode=0x61 & A; opcode=0xF9 & AddrHLOffsetC {
    build SKIP_CHECK;
    AddrHLOffsetC = A;
}

# MOV word[B], #byte
:MOV AddrWordOffsetB, u8 is SKIP_CHECK & opcode=0x19; AddrWordOffsetB; u8 {
    build SKIP_CHECK;
    AddrWordOffsetB = u8;
}

# MOV A, word[B]
:MOV A, AddrWordOffsetB is SKIP_CHECK & opcode=0x09 & A; AddrWordOffsetB {
    build SKIP_CHECK;
    A = AddrWordOffsetB;
}

# MOV word[B], A
:MOV AddrWordOffsetB, A is SKIP_CHECK & opcode=0x18 & A; AddrWordOffsetB {
    build SKIP_CHECK;
    AddrWordOffsetB = A;
}

# MOV word[C], #byte
:MOV AddrWordOffsetC, u8 is SKIP_CHECK & opcode=0x38; AddrWordOffsetC; u8 {
    build SKIP_CHECK;
    AddrWordOffsetC = u8;
}

# MOV A, word[C]
:MOV A, AddrWordOffsetC is SKIP_CHECK & opcode=0x29 & A; AddrWordOffsetC {
    build SKIP_CHECK;
    A = AddrWordOffsetC;
}

# MOV word[C], A
:MOV AddrWordOffsetC, A is SKIP_CHECK & opcode=0x28 & A; AddrWordOffsetC {
    build SKIP_CHECK;
    AddrWordOffsetC = A;
}

# MOV word[BC], #byte
:MOV AddrWordOffsetBC, u8 is SKIP_CHECK & opcode=0x39; AddrWordOffsetBC; u8 {
    build SKIP_CHECK;
    AddrWordOffsetBC = u8;
}

# MOV A, word[BC]
:MOV A, AddrWordOffsetBC is SKIP_CHECK & opcode=0x49 & A; AddrWordOffsetBC {
    build SKIP_CHECK;
    A = AddrWordOffsetBC;
}

# MOV word[BC], A
:MOV AddrWordOffsetBC, A is SKIP_CHECK & opcode=0x48 & A; AddrWordOffsetBC {
    build SKIP_CHECK;
    AddrWordOffsetBC = A;
}

# MOV [SP+byte], #byte
:MOV AddrSPOffset, u8 is SKIP_CHECK & opcode=0xC8; AddrSPOffset; u8 {
    build SKIP_CHECK;
    AddrSPOffset = u8;
}

# MOV A, [SP+byte]
:MOV A, AddrSPOffset is SKIP_CHECK & opcode=0x88 & A; AddrSPOffset {
    build SKIP_CHECK;
    A = AddrSPOffset;
}

# MOV [SP+byte], A
:MOV AddrSPOffset, A is SKIP_CHECK & opcode=0x98 & A; AddrSPOffset {
    build SKIP_CHECK;
    AddrSPOffset = A;
}

# MOV B, saddr
:MOV B, saddr is SKIP_CHECK & opcode=0xE8 & B; saddr {
    build SKIP_CHECK;
    B = saddr;
}

# MOV B, !addr16
:MOV B, addr16 is SKIP_CHECK & opcode=0xE9 & B; addr16 {
    build SKIP_CHECK;
    B = addr16;
}

# MOV C, saddr
:MOV C, saddr is SKIP_CHECK & opcode=0xF8 & C; saddr {
    build SKIP_CHECK;
    C = saddr;
}

# MOV C, !addr16
:MOV C, addr16 is SKIP_CHECK & opcode=0xF9 & C; addr16 {
    build SKIP_CHECK;
    C = addr16;
}

# MOV X, saddr
:MOV X, saddr is SKIP_CHECK & opcode=0xD8 & X; saddr {
    build SKIP_CHECK;
    X = saddr;
}

# MOV X, !addr16
:MOV X, addr16 is SKIP_CHECK & opcode=0xD9 & X; addr16 {
    build SKIP_CHECK;
    X = addr16;
}

#
# Table 3/30
#

# XCH A, X
:XCH A, X is SKIP_CHECK & opcode=0x08 & A & X {
    build SKIP_CHECK;
    inst_xch(A, X);
}

# XCH A, r
:XCH A, SREG2_BYTE is SKIP_CHECK & opcode=0x61; op2_h=0x11 & SREG2_BYTE & sreg2_byte!=1 & A {
    build SKIP_CHECK;
    inst_xch(A, SREG2_BYTE);
}

# XCH A, saddr
:XCH A, saddr is SKIP_CHECK & opcode=0x61 & A; opcode=0xA8; saddr {
    build SKIP_CHECK;
    inst_xch(A, saddr);
}

# XCH A, sfr
:XCH A, sfr_byte is SKIP_CHECK & opcode=0x61 & A; opcode=0xAB; sfr_byte {
    build SKIP_CHECK;
    inst_xch(A, sfr_byte);
}

# XCH A, !addr16
:XCH A, addr16 is SKIP_CHECK & opcode=0x61 & A; opcode=0xAA; addr16 {
    build SKIP_CHECK;
    inst_xch(A, addr16);
}

# XCH A, [DE]
:XCH A, AddrDE is SKIP_CHECK & opcode=0x61 & A; opcode=0xAE & AddrDE {
    build SKIP_CHECK;
    inst_xch(A, AddrDE);
}

# XCH A, [DE+byte]
:XCH A, AddrDEOffset is SKIP_CHECK & opcode=0x61 & A; opcode=0xAF; AddrDEOffset {
    build SKIP_CHECK;
    inst_xch(A, AddrDEOffset);
}

# XCH A, [HL]
:XCH A, AddrHL is SKIP_CHECK & opcode=0x61 & A; opcode=0xAC & AddrHL {
    build SKIP_CHECK;
    inst_xch(A, AddrHL);
}

# XCH A, [HL+byte]
:XCH A, AddrHLOffset is SKIP_CHECK & opcode=0x61 & A; opcode=0xAD; AddrHLOffset {
    build SKIP_CHECK;
    inst_xch(A, AddrHLOffset);
}

# XCH A, [HL+B]
:XCH A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0xB9 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_xch(A, AddrHLOffsetB);
}

# XCH A, [HL+C]
:XCH A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0xA9 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_xch(A, AddrHLOffsetC);
}

#
# Table 4/30
#

# ONEB r
:ONEB DREG_AXBC is SKIP_CHECK & op_h=0xE & op_l<4 & DREG_AXBC {
    build SKIP_CHECK;
    DREG_AXBC = 1;
}

# ONEB saddr
:ONEB saddr is SKIP_CHECK & opcode=0xE4; saddr {
    build SKIP_CHECK;
    saddr = 1;
}

# ONEB !addr16
:ONEB addr16 is SKIP_CHECK & opcode=0xE5; addr16 {
    build SKIP_CHECK;
    addr16 = 1;
}

# CLRB r
:CLRB DREG_AXBC is SKIP_CHECK & op_h=0xF & DREG_AXBC & clrb_unused=0  {
    build SKIP_CHECK;
    DREG_AXBC = 0;
}

# CLRB saddr
:CLRB saddr is SKIP_CHECK & opcode=0xF4; saddr {
    build SKIP_CHECK;
    saddr = 0;
}

# CLRB !addr16
:CLRB addr16 is SKIP_CHECK & opcode=0xF5; addr16 {
    build SKIP_CHECK;
    addr16 = 0;
}

# MOVS [HL+byte], X
:MOVS X, AddrHLOffset ("Check "A" if zero")is SKIP_CHECK & opcode=0x61 & X & A; opcode=0xCE; AddrHLOffset {
    build SKIP_CHECK;
    AddrHLOffset = X;
    $(Z) = (X == 0);
    $(CY) = (X == 0) | (A == 0);
}

# MOVW rp, #word
:MOVW DREG_WORD, u16 is SKIP_CHECK & op_h=0x3 & DREG_WORD; u16 {
    build SKIP_CHECK;
    DREG_WORD = u16;
}

# MOVW saddrp, #word
:MOVW saddrp, u16 is SKIP_CHECK & opcode=0xC9; saddrp; u16 {
    build SKIP_CHECK;
    saddrp = u16;
}

# MOVW sfr, #word
:MOVW sfrpw, u16 is SKIP_CHECK & opcode=0xCB; sfrpw; u16 {
    build SKIP_CHECK;
    sfrpw = u16;
}

# MOVW AX, saddrp
:MOVW AX, saddrp is SKIP_CHECK & opcode=0xAD & AX; saddrp {
    build SKIP_CHECK;
    AX = saddrp;
}

# MOVW saddrp, AX
:MOVW saddrp, AX is SKIP_CHECK & opcode=0xBD & AX; saddrp {
    build SKIP_CHECK;
    saddrp = AX;
}

# MOVW AX, sfrp
:MOVW AX, sfrpw is SKIP_CHECK & opcode=0xAE & AX; sfrpw {
    build SKIP_CHECK;
    AX = sfrpw;
}

# MOVW sfrp, AX
:MOVW sfrpw, AX is SKIP_CHECK & opcode=0xBE & AX; sfrpw {
    build SKIP_CHECK;
    sfrpw = AX;
}

# MOVW AX, rp
:MOVW AX, DREG_WORD is SKIP_CHECK & op_h=0x1 & AX & DREG_WORD & dreg_word!=0 & rp_source=1 {
    build SKIP_CHECK;
    AX = DREG_WORD;
}

# MOVW rp, AX
:MOVW DREG_WORD, AX is SKIP_CHECK & op_h=0x1 & AX & DREG_WORD & dreg_word!=0 & rp_source=0 {
    build SKIP_CHECK;
    DREG_WORD = AX;
}

# MOVW AX, !addr16
:MOVW AX, addr16w is SKIP_CHECK & opcode=0xAF & AX; addr16w {
    build SKIP_CHECK;
    AX = addr16w;
}

# MOVW !addr16, AX
:MOVW addr16w, AX is SKIP_CHECK & opcode=0xBF & AX; addr16w {
    build SKIP_CHECK;
    addr16w = AX;
}

# MOVW AX, [DE]
:MOVW AX, AddrDEW is SKIP_CHECK & opcode=0xA9 & AX & AddrDEW {
    build SKIP_CHECK;
    AX = AddrDEW;
}

# MOVW [DE], AX
:MOVW AddrDEW, AX is SKIP_CHECK & opcode=0xB9 & AX & AddrDEW {
    build SKIP_CHECK;
    AddrDEW = AX;
}

# MOVW AX, [DE+byte]
:MOVW AX, AddrDEOffsetW is SKIP_CHECK & opcode=0xAA & AX; AddrDEOffsetW {
    build SKIP_CHECK;
    AX = AddrDEOffsetW;
}

# MOVW [DE+byte], AX
:MOVW AddrDEOffsetW, AX is SKIP_CHECK & opcode=0xBA & AX; AddrDEOffsetW {
    build SKIP_CHECK;
    AddrDEOffsetW = AX;
}

# MOVW AX, [HL]
:MOVW AX, AddrHLW is SKIP_CHECK & opcode=0xAB & AX & AddrHLW {
    build SKIP_CHECK;
    AX = AddrHLW;
}

# MOVW [HL], AX
:MOVW AddrHLW, AX is SKIP_CHECK & opcode=0xBB & AX & AddrHLW {
    build SKIP_CHECK;
    AddrHLW = AX;
}

# MOVW AX, [HL+byte]
:MOVW AX, AddrHLOffsetW is SKIP_CHECK & opcode=0xAC & AX; AddrHLOffsetW {
    build SKIP_CHECK;
    AX = AddrHLOffsetW;
}

# MOVW [HL+byte], AX
:MOVW AddrHLOffsetW, AX is SKIP_CHECK & opcode=0xBC & AX; AddrHLOffsetW {
    build SKIP_CHECK;
    AddrHLOffsetW = AX;
}

# MOVW AX, word[B]
:MOVW AX, AddrWordOffsetBW is SKIP_CHECK & opcode=0x59 & AX; AddrWordOffsetBW {
    build SKIP_CHECK;
    AX = AddrWordOffsetBW;
}

#
# Table 5/30
#

# MOVW word[B], AX
:MOVW AddrWordOffsetBW, AX is SKIP_CHECK & opcode=0x58 & AX; AddrWordOffsetBW {
    build SKIP_CHECK;
    AddrWordOffsetBW = AX;
}

# MOVW AX, word[C]
:MOVW AX, AddrWordOffsetCW is SKIP_CHECK & opcode=0x69 & AX; AddrWordOffsetCW {
    build SKIP_CHECK;
    AX = AddrWordOffsetCW;
}

# MOVW word[C], AX
:MOVW AddrWordOffsetCW, AX is SKIP_CHECK & opcode=0x68 & AX; AddrWordOffsetCW {
    build SKIP_CHECK;
    AddrWordOffsetCW = AX;
}

# MOVW AX, word[BC]
:MOVW AX, AddrWordOffsetBCW is SKIP_CHECK & opcode=0x79 & AX; AddrWordOffsetBCW {
    build SKIP_CHECK;
    AX = AddrWordOffsetBCW;
}

# MOVW AX, [SP+byte]
:MOVW AX, AddrSPOffsetW is SKIP_CHECK & opcode=0xA8 & AX; AddrSPOffsetW {
    build SKIP_CHECK;
    AX = AddrSPOffsetW;
}

# MOVW [SP+byte], AX
:MOVW AddrSPOffsetW, AX is SKIP_CHECK & opcode=0xB8 & AX; AddrSPOffsetW {
    build SKIP_CHECK;
    AddrSPOffsetW = AX;
}

# MOVW BC, saddrp
:MOVW BC, saddrp is SKIP_CHECK & opcode=0xDA & BC; saddrp {
    build SKIP_CHECK;
    BC = saddrp;
}

# MOVW BC, !addr16
:MOVW BC, addr16w is SKIP_CHECK & opcode=0xDB & BC; addr16w {
    build SKIP_CHECK;
    BC = addr16w;
}

# MOVW DE, saddrp
:MOVW DE, saddrp is SKIP_CHECK & opcode=0xEA & DE; saddrp {
    build SKIP_CHECK;
    DE = saddrp;
}

# MOVW DE, !addr16
:MOVW DE, addr16w is SKIP_CHECK & opcode=0xEB & DE; addr16w {
    build SKIP_CHECK;
    DE = addr16w;
}

# MOVW HL, saddrp
:MOVW HL, saddrp is SKIP_CHECK & opcode=0xFA & HL; saddrp {
    build SKIP_CHECK;
    HL = saddrp;
}

# MOVW HL, !addr16
:MOVW HL, addr16w is SKIP_CHECK & opcode=0xFB & HL; addr16w {
    build SKIP_CHECK;
    HL = addr16w;
}

# XCHW AX, rp
:XCHW AX, DREG_WORD is SKIP_CHECK & op_h=0x3 & rp_source=1 & DREG_WORD & dreg_word!=0 & AX {
    build SKIP_CHECK;
    local tmp = AX;
    AX = DREG_WORD;
    DREG_WORD = tmp;
}

# ONEW AX
:ONEW AX is SKIP_CHECK & opcode=0xE6 & AX {
    build SKIP_CHECK;
    AX = 1;
}

# ONEW BC
:ONEW BC is SKIP_CHECK & opcode=0xE7 & BC {
    build SKIP_CHECK;
    BC = 1;
}

# CLRW AX
:CLRW AX is SKIP_CHECK & opcode=0xF6 & AX {
    build SKIP_CHECK;
    AX = 0;
}

# CLRW BC
:CLRW BC is SKIP_CHECK & opcode=0xF7 & BC {
    build SKIP_CHECK;
    BC = 0;
}

#
# Table 6/30
#

# ADD A, #byte
:ADD A, u8 is SKIP_CHECK & opcode=0x0C & A; u8 {
    build SKIP_CHECK;
    inst_add(A, u8);
}

# ADD saddr, #byte
:ADD saddr, u8 is SKIP_CHECK & opcode=0x0A; saddr; u8 {
    build SKIP_CHECK;
    inst_add(saddr, u8);
}

# ADD A, r
:ADD A, "A" is SKIP_CHECK & opcode=0x61 & A; opcode=0x1 {
    build SKIP_CHECK;
    inst_add(A, A);
}

# ADD A, r
:ADD A, SREG2_BYTE is SKIP_CHECK & opcode=0x61 & A; op2_h=0x01 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_add(A, SREG2_BYTE);
}

# ADD r, A
:ADD SREG2_BYTE, A is SKIP_CHECK & opcode=0x61 & A; op2_h=0x00 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_add(SREG2_BYTE, A);
}

# ADD A, saddr
:ADD A, saddr is SKIP_CHECK & opcode=0x0B & A; saddr {
    build SKIP_CHECK;
    inst_add(A, saddr);
}

# ADD A, !addr16
:ADD A, addr16 is SKIP_CHECK & opcode=0x0F & A; addr16 {
    build SKIP_CHECK;
    inst_add(A, addr16);
}

# ADD A, [HL]
:ADD A, AddrHL is SKIP_CHECK & opcode=0x0D & A & AddrHL {
    build SKIP_CHECK;
    inst_add(A, AddrHL);
}

# ADD A, [HL+byte]
:ADD A, AddrHLOffset is SKIP_CHECK & opcode=0x0E & A; AddrHLOffset {
    build SKIP_CHECK;
    inst_add(A, AddrHLOffset);
}

# ADD A, [HL+B]
:ADD A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0x80 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_add(A, AddrHLOffsetB);
}

# ADD A, [HL+C]
:ADD A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0x82 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_add(A, AddrHLOffsetC);
}

# ADDC A, #byte
:ADDC A, u8 is SKIP_CHECK & opcode=0x1C & A; u8 {
    build SKIP_CHECK;
    inst_addc(A, u8);
}

# ADDC saddr, #byte
:ADDC saddr, u8 is SKIP_CHECK & opcode=0x1A; saddr; u8 {
    build SKIP_CHECK;
    inst_addc(saddr, u8);
}

# ADDC A, r
:ADDC A, SREG2_BYTE is SKIP_CHECK & opcode=0x61 & A; op2_h=0x3 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_addc(A, SREG2_BYTE);
}

# ADDC r, A
:ADDC SREG2_BYTE, A is SKIP_CHECK & opcode=0x61 & A; op2_h=0x2 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_addc(A, SREG2_BYTE);
}

#
# Table 7/30
#

# ADDC A, saddr
:ADDC A, saddr is SKIP_CHECK & opcode=0x1B & A; saddr {
    build SKIP_CHECK;
    inst_addc(A, saddr);
}

# ADDC A, !uint16
:ADDC A, addr16 is SKIP_CHECK & opcode=0x1F & A; addr16 {
    build SKIP_CHECK;
    inst_addc(A, addr16);
}

# ADDC A, [HL]
:ADDC A, AddrHL is SKIP_CHECK & opcode=0x1D & A & AddrHL {
    build SKIP_CHECK;
    inst_addc(A, AddrHL);
}

# ADDC A, [HL+byte]
:ADDC A, AddrHLOffset is SKIP_CHECK & opcode=0x1E & A; AddrHLOffset {
    build SKIP_CHECK;
    inst_addc(A, AddrHLOffset);
}

# ADDC A, [HL+B]
:ADDC A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0x90 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_addc(A, AddrHLOffsetB);
}

# ADDC A, [HL+C]
:ADDC A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0x92 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_addc(A, AddrHLOffsetC);
}

# SUB A, #byte
:SUB A, u8 is SKIP_CHECK & opcode=0x2C & A; u8 {
    build SKIP_CHECK;
    inst_sub(A, u8);
}

# SUB saddr, #byte
:SUB saddr, u8 is SKIP_CHECK & opcode=0x2A; saddr; u8 {
    build SKIP_CHECK;
    inst_sub(saddr, u8);
}

# SUB A, r
:SUB A, SREG2_BYTE is SKIP_CHECK & opcode=0x61 & A; op2_h=0x5 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_sub(A, SREG2_BYTE);
}

# SUB r, A
:SUB SREG2_BYTE, A is SKIP_CHECK & opcode=0x61 & A; op2_h=0x4 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_sub(SREG2_BYTE, A);
}

# SUB A, saddr
:SUB A, saddr is SKIP_CHECK & opcode=0x2B & A; saddr {
    build SKIP_CHECK;
    inst_sub(A, saddr);
}

# SUB A, !addr16
:SUB A, addr16 is SKIP_CHECK & opcode=0x2F & A; addr16 {
    build SKIP_CHECK;
    inst_sub(A, addr16);
}

# SUB A, [HL]
:SUB A, AddrHL is SKIP_CHECK & opcode=0x2D & A & AddrHL {
    build SKIP_CHECK;
    inst_sub(A, AddrHL);
}

# SUB A, [HL+byte]
:SUB A, AddrHLOffset is SKIP_CHECK & opcode=0x2E & A; AddrHLOffset {
    build SKIP_CHECK;
    inst_sub(A, AddrHLOffset);
}

# SUB A, [HL+B]
:SUB A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0xA0 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_sub(A, AddrHLOffsetB);
}

# SUB A, [HL+C]
:SUB A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0xA2 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_sub(A, AddrHLOffsetC);
}

#
# Table 8/30
#

# SUBC A, #byte
:SUBC A, u8 is SKIP_CHECK & opcode=0x3C & A; u8 {
    build SKIP_CHECK;
    inst_subc(A, u8);
}

# SUBC saddr, #byte
:SUBC saddr, u8 is SKIP_CHECK & opcode=0x3A; saddr; u8 {
    build SKIP_CHECK;
    inst_subc(saddr, u8);
}

# SUBC A, r
:SUBC A, SREG2_BYTE is SKIP_CHECK & opcode=0x61 & A; op2_h=0x7 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_subc(A, SREG2_BYTE);
}

# SUBC r, A
:SUBC SREG2_BYTE, A is SKIP_CHECK & opcode=0x61 & A; op2_h=0x6 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_subc(SREG2_BYTE, A);
}

# SUBC A, saddr
:SUBC A, saddr is SKIP_CHECK & opcode=0x3B & A; saddr {
    build SKIP_CHECK;
    inst_subc(A, saddr);
}

# SUBC A, !addr16
:SUBC A, addr16 is SKIP_CHECK & opcode=0x3F & A; addr16 {
    build SKIP_CHECK;
    inst_subc(A, addr16);
}

# SUBC A, [HL]
:SUBC A, AddrHL is SKIP_CHECK & opcode=0x3D & A & AddrHL {
    build SKIP_CHECK;
    inst_subc(A, AddrHL);
}

# SUBC A, [HL+byte]
:SUBC A, AddrHLOffset is SKIP_CHECK & opcode=0x3E & A; AddrHLOffset {
    build SKIP_CHECK;
    inst_subc(A, AddrHLOffset);
}

# SUBC A, [HL+B]
:SUBC A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0xB0 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_subc(A, AddrHLOffsetB);
}

# SUBC A, [HL+C]
:SUBC A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0xB2 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_subc(A, AddrHLOffsetC);
}

# AND A, #byte
:AND A, u8 is SKIP_CHECK & opcode=0x5C & A; u8 {
    build SKIP_CHECK;
    inst_and(A, u8);
}

# AND saddr, #byte
:AND saddr, u8 is SKIP_CHECK & opcode=0x5A; saddr; u8 {
    build SKIP_CHECK;
    inst_and(saddr, u8);
}

# AND A, r
:AND A, SREG2_BYTE is SKIP_CHECK & opcode=0x61 & A; op2_h=0xB & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_and(A, SREG2_BYTE);
}

# AND r, A
:AND SREG2_BYTE, A is SKIP_CHECK & opcode=0x61 & A; op2_h=0xA & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_and(SREG2_BYTE, A);
}

#
# Table 9/30
#

# AND A, saddr
:AND A, saddr is SKIP_CHECK & opcode=0x5B & A; saddr {
    build SKIP_CHECK;
    inst_and(A, saddr);
}

# AND A, !addr16
:AND A, addr16 is SKIP_CHECK & opcode=0x5F & A; addr16 {
    build SKIP_CHECK;
    inst_and(A, addr16);
}

# AND A, [HL]
:AND A, AddrHL is SKIP_CHECK & opcode=0x5D & A & AddrHL {
    build SKIP_CHECK;
    inst_and(A, AddrHL);
}

# AND A, [HL+byte]
:AND A, AddrHLOffset is SKIP_CHECK & opcode=0x5E & A; AddrHLOffset {
    build SKIP_CHECK;
    inst_and(A, AddrHLOffset);
}

# AND A, [HL+B]
:AND A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0xD0 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_and(A, AddrHLOffsetB);
}

# AND A, [HL+C]
:AND A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0xD2 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_and(A, AddrHLOffsetC);
}

# OR A, #byte
:OR A, u8 is SKIP_CHECK & opcode=0x6C & A; u8 {
    build SKIP_CHECK;
    inst_or(A, u8);
}

# OR saddr, #byte
:OR saddr, u8 is SKIP_CHECK & opcode=0x6A; saddr; u8 {
    build SKIP_CHECK;
    inst_or(saddr, u8);
}

# OR A, r
:OR A, SREG2_BYTE is SKIP_CHECK & opcode=0x61 & A; op2_h=0xD & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_or(A, SREG2_BYTE);
}

# OR r, A
:OR SREG2_BYTE, A is SKIP_CHECK & opcode=0x61 & A; op2_h=0xC & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_or(SREG2_BYTE, A);
}

# OR A, saddr
:OR A, saddr is SKIP_CHECK & opcode=0x6B & A; saddr {
    build SKIP_CHECK;
    inst_or(A, saddr);
}

# OR A, !addr16
:OR A, addr16 is SKIP_CHECK & opcode=0x6F & A; addr16 {
    build SKIP_CHECK;
    inst_or(A, addr16);
}

# OR A, [HL]
:OR A, AddrHL is SKIP_CHECK & opcode=0x6D & A & AddrHL {
    build SKIP_CHECK;
    inst_or(A, AddrHL);
}

# OR A, [HL+byte]
:OR A, AddrHLOffset is SKIP_CHECK & opcode=0x6E & A; AddrHLOffset {
    build SKIP_CHECK;
    inst_or(A, AddrHLOffset);
}

# OR A, [HL+B]
:OR A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0xE0 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_or(A, AddrHLOffsetB);
}

# OR A, [HL+C]
:OR A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0xE2 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_or(A, AddrHLOffsetC);
}

#
# Table 10/30
#

# XOR A, #byte
:XOR A, u8 is SKIP_CHECK & opcode=0x7C & A; u8 {
    build SKIP_CHECK;
    inst_xor(A, u8);
}

# XOR saddr, #byte
:XOR saddr, u8 is SKIP_CHECK & opcode=0x7A; saddr; u8 {
    build SKIP_CHECK;
    inst_xor(saddr, u8);
}

# XOR A, r
:XOR A, SREG2_BYTE is SKIP_CHECK & opcode=0x61 & A; op2_h=0xf & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_xor(A, SREG2_BYTE);
}

# XOR r, A
:XOR SREG2_BYTE, A is SKIP_CHECK & opcode=0x61 & A; op2_h=0xe & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_xor(SREG2_BYTE, A);
}

# XOR A, saddr
:XOR A, saddr is SKIP_CHECK & opcode=0x7B & A; saddr {
    build SKIP_CHECK;
    inst_xor(A, saddr);
}

# XOR A, !addr16
:XOR A, addr16 is SKIP_CHECK & opcode=0x7f & A; addr16 {
    build SKIP_CHECK;
    inst_xor(A, addr16);
}

# XOR A, [HL]
:XOR A, AddrHL is SKIP_CHECK & opcode=0x7D & A & AddrHL {
    build SKIP_CHECK;
    inst_xor(A, AddrHL);
}

# XOR A, [HL+byte]
:XOR A, AddrHLOffset is SKIP_CHECK & opcode=0x7E & A; AddrHLOffset {
    build SKIP_CHECK;
    inst_xor(A, AddrHLOffset);
}

# XOR A, [HL+B]
:XOR A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0xF0 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_xor(A, AddrHLOffsetB);
}

# XOR A, [HL+C]
:XOR A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0xF2 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_xor(A, AddrHLOffsetC);
}

# CMP A, #byte
:CMP A, u8 is SKIP_CHECK & opcode=0x4C & A; u8 {
    build SKIP_CHECK;
    inst_cmp(A, u8);
}

# CMP saddr, #byte
:CMP saddr, u8 is SKIP_CHECK & opcode=0x4A; saddr; u8 {
    build SKIP_CHECK;
    inst_cmp(saddr, u8);
}

# NOTE: Similar to XOR above, CMP can be simplified by looking
# at the 5 upper bits of the second byte of the instruction.
# 0x48 -> 0x9

# CMP A, r
:CMP A, SREG2_BYTE is SKIP_CHECK & opcode=0x61 & A; op2_h=0x9 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_cmp(A, SREG2_BYTE);
}

# CMP r, A
:CMP SREG2_BYTE, A is SKIP_CHECK & opcode=0x61 & A; op2_h=0x8 & SREG2_BYTE & sreg2_byte!=1 {
    build SKIP_CHECK;
    inst_cmp(SREG2_BYTE, A);
}

#
# Table 11/30
#

# CMP A, saddr
:CMP A, saddr is SKIP_CHECK & opcode=0x4B & A; saddr {
    build SKIP_CHECK;
    inst_cmp(A, saddr);
}

# CMP A, !addr16
:CMP A, addr16 is SKIP_CHECK & opcode=0x4F & A; addr16 {
    build SKIP_CHECK;
    inst_cmp(A, addr16);
}

# CMP A, [HL]
:CMP A, AddrHL is SKIP_CHECK & opcode=0x4D & A & AddrHL {
    build SKIP_CHECK;
    inst_cmp(A, AddrHL);
}

# CMP A, [HL+byte]
:CMP A, AddrHLOffset is SKIP_CHECK & opcode=0x4E & A; AddrHLOffset {
    build SKIP_CHECK;
    inst_cmp(A, AddrHLOffset);
}

# CMP A, [HL+B]
:CMP A, AddrHLOffsetB is SKIP_CHECK & opcode=0x61 & A; opcode=0xC0 & AddrHLOffsetB {
    build SKIP_CHECK;
    inst_cmp(A, AddrHLOffsetB);
}

# CMP A, [HL+C]
:CMP A, AddrHLOffsetC is SKIP_CHECK & opcode=0x61 & A; opcode=0xC2 & AddrHLOffsetC {
    build SKIP_CHECK;
    inst_cmp(A, AddrHLOffsetC);
}

# CMP !addr16, #byte
:CMP addr16, u8 is SKIP_CHECK & opcode=0x40; addr16; u8 {
    build SKIP_CHECK;
    inst_cmp(addr16, u8);
}

# CMP0, r
:CMP0 DREG_AXBC is SKIP_CHECK & op_h=0xD & op_l<4 & DREG_AXBC {
    build SKIP_CHECK;
    inst_cmp0(DREG_AXBC);
}

# CMP0 saddr
:CMP0 saddr is SKIP_CHECK & opcode=0xD4; saddr {
    build SKIP_CHECK;
    inst_cmp0(saddr);
}

# CMP0 !addr16
:CMP0 addr16 is SKIP_CHECK & opcode=0xD5; addr16 {
    build SKIP_CHECK;
    inst_cmp0(addr16);
}

# CMPS X, [HL+byte]
:CMPS X, AddrHLOffset is SKIP_CHECK & opcode=0x61 & X; opcode=0xDE; AddrHLOffset {
    build SKIP_CHECK;
    $(Z) = X == AddrHLOffset;
    $(CY) = ($(Z) != 0) | (AddrHLOffset == 0) | (X == 0);
    aux_borrow(X, AddrHLOffset);
}

# ADDW AX, #word
:ADDW AX, u16 is SKIP_CHECK & opcode=0x04 & AX; u16 {
    build SKIP_CHECK;
    inst_addw(AX, u16);
}

# ADDW AX, AX
:ADDW "AX", "AX" is SKIP_CHECK & AX & opcode=0x1 {
    build SKIP_CHECK;
    inst_addw(AX, AX);
}

# ADDW AX, rp
:ADDW AX, DREG_WORD is SKIP_CHECK & op_h=0x0 & AX & rp_source=1 & movw_op=0 & DREG_WORD & dreg_word!=0 {
    build SKIP_CHECK;
    inst_addw(AX, DREG_WORD);
}

# ADDW AX, saddrp
:ADDW AX, saddrp is SKIP_CHECK & opcode=0x06 & AX; saddrp {
    build SKIP_CHECK;
    inst_addw(AX, saddrp);
}

# ADDW AX, !addr16
:ADDW AX, addr16w is SKIP_CHECK & opcode=0x02 & AX; addr16w {
    build SKIP_CHECK;
    inst_addw(AX, addr16w);
}

# ADDW AX, [HL+byte]
:ADDW AX, AddrHLOffsetW is SKIP_CHECK & opcode=0x61 & AX; opcode=0x09; AddrHLOffsetW {
    build SKIP_CHECK;
    inst_addw(AX, AddrHLOffsetW);
}

# SUBW AX, #word
:SUBW AX, u16 is SKIP_CHECK & opcode=0x24 & AX; u16 {
    build SKIP_CHECK;
    inst_subw(AX, u16);
}

# SUBW AX, rp
:SUBW AX, DREG_WORD is SKIP_CHECK & op_h=0x2 & AX & rp_source=1 & movw_op=0 & DREG_WORD & dreg_word!=0 {
    build SKIP_CHECK;
    inst_subw(AX, DREG_WORD);
}

# SUBW AX, saddrp
:SUBW AX, saddrp is SKIP_CHECK & opcode=0x26 & AX; saddrp {
    build SKIP_CHECK;
    inst_subw(AX, saddrp);
}

# SUBW AX, !addr16
:SUBW AX, addr16w is SKIP_CHECK & opcode=0x22 & AX; addr16w {
    build SKIP_CHECK;
    inst_subw(AX, addr16w);
}

# SUBW AX, [HL+byte]
:SUBW AX, AddrHLOffsetW is SKIP_CHECK & opcode=0x61 & AX; opcode=0x29; AddrHLOffsetW {
    build SKIP_CHECK;
    inst_subw(AX, AddrHLOffsetW);
}

#
# Table 12/30
#

# CMPW AX, #word
:CMPW AX, u16 is SKIP_CHECK & opcode=0x44 & AX; u16 {
    build SKIP_CHECK;
    inst_cmpw(AX, u16);
}

# CMPW AX, rp
:CMPW AX, DREG_WORD is SKIP_CHECK & op_h=0x4 & AX & rp_source=1 & movw_op=0 & DREG_WORD & dreg_word!=0 {
    build SKIP_CHECK;
    inst_cmpw(AX, DREG_WORD);
}

# CMPW AX, saddrp
:CMPW AX, saddrp is SKIP_CHECK & opcode=0x46 & AX; saddrp {
    build SKIP_CHECK;
    inst_cmpw(AX, saddrp);
}

# CMPW AX, !addr16
:CMPW AX, addr16w is SKIP_CHECK & opcode=0x42 & AX; addr16w {
    build SKIP_CHECK;
    inst_cmpw(AX, addr16w);
}

# CMPW AX, [HL+byte]
:CMPW AX, AddrHLOffsetW is SKIP_CHECK & opcode=0x61 & AX; opcode=0x49; AddrHLOffsetW {
    build SKIP_CHECK;
    inst_cmpw(AX, AddrHLOffsetW);
}

# MULU X
:MULU X (AX"="A"*X") is SKIP_CHECK & opcode=0xD6 & AX & X & A {
    build SKIP_CHECK;
    local aw:2 = zext(A:1);
    local xw:2 = zext(X:1);
    AX = aw * xw;
}

# MULHU
:MULHU ("AXBC="AX"*"BC) is SKIP_CHECK & opcode=0xCE; opcode=0xFB; opcode=0x01 & AX & BC {
    build SKIP_CHECK;
    local axdw:4 = zext(AX:2);
    local bcdw:4 = zext(BC:2);
    local res:4 = axdw * bcdw;

    bcdw = (res & 0xFFFF0000) >> 16;
    axdw = (res & 0x0000FFFF);

    BC = bcdw:2;
    AX = axdw:2;
}

# MULH
:MULH ("AXBC="AX"*"BC) is SKIP_CHECK & opcode=0xCE; opcode=0xFB; opcode=0x02 & AX & BC {
    build SKIP_CHECK;
    local axdw:4 = sext(AX:2);
    local bcdw:4 = sext(BC:2);
    local res:4 = axdw * bcdw;

    bcdw = (res & 0xFFFF0000) >> 16;
    axdw = (res & 0x0000FFFF);

    BC = bcdw:2;
    AX = axdw:2;
}

# DIVHU
:DIVHU ("AXDE="AX"/"DE) is SKIP_CHECK & opcode=0xCE; opcode=0xFB; opcode=0x03 & AX & DE {
    build SKIP_CHECK;
    local axdw:4 = zext(AX:2);
    local dedw:4 = zext(DE:2);

    # Doesn't handle the case where DE is SKIP_CHECK & 0
    local div:4 = axdw / dedw;
    local rem:4 = axdw % dedw;

    dedw = div & 0xFFFF;
    axdw = rem & 0xFFFF;

    DE = dedw:2;
    AX = axdw:2;
}

# DIVWU
:DIVWU is SKIP_CHECK & opcode=0xCE; opcode=0xFB; opcode=0x04 { divwu(); }

# MACHU
:MACHU is SKIP_CHECK & opcode=0xCE; opcode=0xFB; opcode=0x05 { machu(); }

# MACH
:MACH is SKIP_CHECK & opcode=0xCE; opcode=0xFB; opcode=0x06 { mach(); }

# INC r
:INC DREG_BYTE is SKIP_CHECK & op_h=0x8 & DREG_BYTE {
    build SKIP_CHECK;
    inst_inc(DREG_BYTE);
}

# INC saddr
:INC saddr is SKIP_CHECK & opcode=0xA4; saddr {
    build SKIP_CHECK;
    inst_inc(saddr);
}

# INC !addr16
:INC addr16 is SKIP_CHECK & opcode=0xA0; addr16 {
    build SKIP_CHECK;
    inst_inc(addr16);
}

# INC [HL+byte]
:INC AddrHLOffset is SKIP_CHECK & opcode=0x61; opcode=0x59; AddrHLOffset {
    build SKIP_CHECK;
    inst_inc(AddrHLOffset);
}

# DEC r
:DEC DREG_BYTE is SKIP_CHECK & op_h=0x9 & DREG_BYTE {
    build SKIP_CHECK;
    inst_dec(DREG_BYTE);
}

# DEC saddr
:DEC saddr is SKIP_CHECK & opcode=0xB4; saddr {
    build SKIP_CHECK;
    inst_dec(saddr);
}

# DEC !addr16
:DEC addr16 is SKIP_CHECK & opcode=0xB0; addr16 {
    build SKIP_CHECK;
    inst_dec(addr16);
}

# DEC [HL+byte]
:DEC AddrHLOffset is SKIP_CHECK & opcode=0x61; opcode=0x69; AddrHLOffset {
    build SKIP_CHECK;
    inst_dec(AddrHLOffset);
}

#
# Table 13
#

# INCW rp
:INCW DREG_WORD is SKIP_CHECK & op_h=0xA & DREG_WORD {
    build SKIP_CHECK;
    inst_incw(DREG_WORD);
}

# INCW saddrp
:INCW saddrp is SKIP_CHECK & opcode=0xA6; saddrp {
    build SKIP_CHECK;
    inst_incw(saddrp);
}

# INCW !addr16
:INCW addr16w is SKIP_CHECK & opcode=0xA2; addr16w {
    build SKIP_CHECK;
    inst_incw(addr16w);
}

# INCW [HL+byte]
:INCW AddrHLOffsetW is SKIP_CHECK & opcode=0x61; opcode=0x79; AddrHLOffsetW {
    build SKIP_CHECK;
    inst_incw(AddrHLOffsetW);
}

# DECW rp
:DECW DREG_WORD is SKIP_CHECK & op_h=0xB & DREG_WORD {
    build SKIP_CHECK;
    inst_decw(DREG_WORD);
}

# DECW saddrp
:DECW saddrp is SKIP_CHECK & opcode=0xB6; saddrp {
    build SKIP_CHECK;
    inst_decw(saddrp);
}

# DECW !addr16
:DECW addr16w is SKIP_CHECK & opcode=0xB2; addr16w {
    build SKIP_CHECK;
    inst_decw(addr16w);
}

# DECW [HL+byte]
:DECW AddrHLOffset is SKIP_CHECK & opcode=0x61; opcode=0x89; AddrHLOffset {
    build SKIP_CHECK;
    inst_decw(AddrHLOffset);
}

# SHR A, n
:SHR A, shift_n is SKIP_CHECK & opcode=0x31 & A; op2_l=0xA & shift_n {
    build SKIP_CHECK;
    inst_shr(A, shift_n);
}

# SHRW AX, n
:SHRW AX, shift_n is SKIP_CHECK & opcode=0x31 & AX; op2_l=0xE & shift_n {
    build SKIP_CHECK;
    inst_shr(AX, shift_n);
}

#
# Table 14/30
#

# SHL A, n
:SHL A, shift_n is SKIP_CHECK & opcode=0x31 & A; op2_l=0x9 & shift_n {
    build SKIP_CHECK;
    inst_shl(A, shift_n);
}

# SHL B, n
:SHL B, shift_n is SKIP_CHECK & opcode=0x31 & B; op2_l=0x8 & shift_n {
    build SKIP_CHECK;
    inst_shl(B, shift_n);
}

# SHL C, n
:SHL C, shift_n is SKIP_CHECK & opcode=0x31 & C; op2_l=0x7 & shift_n {
    build SKIP_CHECK;
    inst_shl(C, shift_n);
}

# SHLW AX, n
:SHLW AX, shift_n is SKIP_CHECK & opcode=0x31 & AX; op2_l=0xD & shift_n {
    build SKIP_CHECK;
    inst_shlw(AX, shift_n);
}

# SHLW BC, n
:SHLW BC, shift_n is SKIP_CHECK & opcode=0x31 & BC; op2_l=0xC & shift_n {
    build SKIP_CHECK;
    inst_shlw(BC, shift_n);
}

#
# Table 15/30
#

# SAR A, n
:SAR A, shift_n is SKIP_CHECK & opcode=0x31 & A; op2_l=0xB & shift_n {
    build SKIP_CHECK;
    inst_sar(A, shift_n);
}

# SARW AX, n
:SARW AX, shift_n is SKIP_CHECK & opcode=0x31 & AX; op2_l=0xF & shift_n {
    build SKIP_CHECK;
    inst_sarw(AX, shift_n);
}

# ROR A, 1
:ROR A, 1 is SKIP_CHECK & opcode=0x61 & A; opcode=0xDB {
    build SKIP_CHECK;
    local lsb:1 = A & 0x1;
    $(CY) = (lsb != 0);
    A = A >> 1;
    A = A & ($(CY) << 7);
}

# ROL A, 1
:ROL A, 1 is SKIP_CHECK & opcode=0x61 & A; opcode=0xEB {
    build SKIP_CHECK;
    local msb:1 = A & 0x80;
    $(CY) = (msb != 0);
    A = A << 1;
    A = A | $(CY);
}

# RORC A, 1
:RORC A, 1 is SKIP_CHECK & opcode=0x61 & A; opcode=0xFB {
    build SKIP_CHECK;
    local lsb:1 = A & 1;
    A = A >> 1;
    A = ($(CY) << 7);
    $(CY) = lsb;
}

# ROLC A, 1
:ROLC A, 1 is SKIP_CHECK & opcode=0x61 & A; opcode=0xDC {
    build SKIP_CHECK;
    local msb:1 = (A & 0x80) != 0;
    A = A << 1;
    A = A | $(CY);
    $(CY) = msb;
}

# ROLWC AX, 1
:ROLWC AX, 1 is SKIP_CHECK & opcode=0x61 & AX; opcode=0xEE {
    build SKIP_CHECK;
    inst_rolwc(AX);
}

# ROLWC BC, 1
:ROLWC BC, 1 is SKIP_CHECK & opcode=0x61 & BC; opcode=0xBC {
    build SKIP_CHECK;
    inst_rolwc(BC);
}

# MOV1 CY, saddr.n
:MOV1 "CY", saddr"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0x4 & bit_op_n & mov1_sreg=0; saddr {
    build SKIP_CHECK;
    local tmp:1 = $(CY);
    mov1_read(tmp, saddr, bit_op_n);
    $(CY) = tmp;
}

#
# Table 16/30
#

# MOV1 CY, sfr.n
:MOV1 "CY", sfrp"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0xC & bit_op_n & mov1_sreg=0; sfrp {
    build SKIP_CHECK;
    local tmp:1 = $(CY);
    mov1_read(tmp, sfrp, bit_op_n);
    $(CY) = tmp;
}

# MOV1 CY, A.n
:MOV1 "CY", A"."bit_op_n is SKIP_CHECK & opcode=0x71 & A; op_l=0xC & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    local tmp:1 = $(CY);
    mov1_read(tmp, A, bit_op_n);
    $(CY) = tmp;
}

# MOV1 CY, PSW.n
:MOV1 "CY", PSW"."bit_op_n is SKIP_CHECK & opcode=0x71 & PSW; op_l=0xC & bit_op_n; opcode=0xFA {
    build SKIP_CHECK;
    local tmp:1 = $(CY);
    mov1_read(tmp, PSW, bit_op_n);
    $(CY) = tmp;
}

# MOV1 CY, [HL].0
:MOV1 "CY", AddrHL"."bit_op_n is SKIP_CHECK & opcode=0x71 & AddrHL; op_l=0x4 & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    local tmp:1 = $(CY);
    mov1_read(tmp, AddrHL, bit_op_n);
    $(CY) = tmp;
}

# MOV1 saddr.n, CY
:MOV1 saddr"."bit_op_n, "CY" is SKIP_CHECK & opcode=0x71; op_l=0x1 & bit_op_n & mov1_sreg=0; saddr {
    build SKIP_CHECK;
    mov1_write(saddr, $(CY), bit_op_n);
}

#
# Table 17/30
#

# MOV1 sfr.n, CY
:MOV1 sfrp"."bit_op_n, "CY" is SKIP_CHECK & opcode=0x71; op_l=0x9 & bit_op_n & mov1_sreg=0; sfrp {
    build SKIP_CHECK;
    mov1_write(sfrp, $(CY), bit_op_n);
}

# MOV1 A.n, CY
:MOV1 A"."bit_op_n & 0x7, "CY" is SKIP_CHECK & opcode=0x71 & A; op_l=0x9 & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    mov1_write(A, $(CY), bit_op_n);
}

# MOV1 PSW.n, CY
:MOV1 PSW"."bit_op_n, "CY" is SKIP_CHECK & opcode=0x71 & PSW; op_l=0x9 & bit_op_n & mov1_sreg=0; opcode=0xFA {
    build SKIP_CHECK;
    mov1_write(PSW, $(CY), bit_op_n);
}

# MOV1 [HL].n, CY
:MOV1 AddrHL"."bit_op_n, "CY" is SKIP_CHECK & opcode=0x71 & AddrHL; op_l=0x1 & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    mov1_write(AddrHL, $(CY), bit_op_n);
}

#
# Table 18/30
#

# AND1 CY, saddr.n
:AND1 "CY", saddr"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0x5 & bit_op_n & mov1_sreg=0; saddr {
    build SKIP_CHECK;
    inst_and1(saddr, bit_op_n);
}

# AND1 CY, sfr.n
:AND1 "CY", sfrp"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0xD & bit_op_n & mov1_sreg=0; sfrp {
    build SKIP_CHECK;
    inst_and1(sfrp, bit_op_n);
}

# AND1 CY, A.n
:AND1 "CY", A"."bit_op_n is SKIP_CHECK & opcode=0x71 & A; op_l=0xD & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_and1(A, bit_op_n);
}

# AND1 CY, PSW.n
:AND1 "CY", PSW"."bit_op_n is SKIP_CHECK & opcode=0x71 & PSW; op_l=0xD & bit_op_n & mov1_sreg=0; opcode=0xFA {
    build SKIP_CHECK;
    inst_and1(PSW, bit_op_n);
}

#
# Table 19/30
#

# AND1 CY, [HL].n
:AND1 "CY", AddrHL"."bit_op_n is SKIP_CHECK & opcode=0x71 & AddrHL; op_l=0x5 & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_and1(AddrHL, bit_op_n);
}

# OR1 CY, saddr.n
:OR1 "CY", saddr"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0x6 & bit_op_n & mov1_sreg=0; saddr {
    build SKIP_CHECK;
    inst_or1(saddr, bit_op_n);
}

# OR1 CY, sfr.n
:OR1 "CY", sfrp"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0xE & bit_op_n & mov1_sreg=0; sfrp {
    build SKIP_CHECK;
    inst_or1(sfrp, bit_op_n);
}

# OR1 CY, A.n
:OR1 "CY", A"."bit_op_n is SKIP_CHECK & opcode=0x71 & A; op_l=0xE & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_or1(A, bit_op_n);
}

#
# Table 20/30
#

# OR1 CY, PSW.n
:OR1 "CY", PSW"."bit_op_n is SKIP_CHECK & opcode=0x71 & PSW; op_l=0xE & bit_op_n & mov1_sreg=0; opcode=0xFA {
    build SKIP_CHECK;
    inst_or1(PSW, bit_op_n);
}

# OR1 CY, [HL].n
:OR1 "CY", AddrHL"."bit_op_n is SKIP_CHECK & opcode=0x71 & AddrHL; op_l=0x6 & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_or1(AddrHL, bit_op_n);
}

# XOR1 CY, saddr.n
:XOR1 "CY", saddr"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0x7 & bit_op_n & mov1_sreg=0; saddr {
    build SKIP_CHECK;
    inst_xor1(saddr, bit_op_n);
}

# XOR1 CY, sfr.n
:XOR1 "CY", sfrp"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0xF & bit_op_n & mov1_sreg=0; sfrp {
    build SKIP_CHECK;
    inst_xor(sfrp, bit_op_n);
}

#
# Table 21/30
#

# XOR1 CY, A.n
:XOR1 "CY", A"."bit_op_n is SKIP_CHECK & opcode=0x71 & A; op_l=0xF & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_xor(A, bit_op_n);
}

# XOR1 CY, PSW.n
:XOR1 "CY", PSW"."bit_op_n is SKIP_CHECK & opcode=0x71 & PSW; op_l=0xF & bit_op_n & mov1_sreg=0; opcode=0xFA {
    build SKIP_CHECK;
    inst_xor(PSW, bit_op_n);
}

# XOR1 CY, [HL].n
:XOR1 "CY", AddrHL"."bit_op_n is SKIP_CHECK & opcode=0x71 & AddrHL; op_l=0x7 & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_xor(PSW, bit_op_n);
}

# SET1 saddr.n
:SET1 saddr"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0x2 & bit_op_n & mov1_sreg=0; saddr {
    build SKIP_CHECK;
    inst_set1(saddr, bit_op_n);
}

#
# Table 22/30
#

# SET1 sfr.n
:SET1 sfrp"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0xA & bit_op_n & mov1_sreg=0; sfrp {
    build SKIP_CHECK;
    inst_set1(sfrp, bit_op_n);
}

# SET1 A.n
:SET1 A"."bit_op_n is SKIP_CHECK & opcode=0x71 & A; op_l=0xA & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_set1(A, bit_op_n);
}

# SET1 !addr16.n
:SET1 addr16"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0 & bit_op_n & mov1_sreg=0; addr16 {
    build SKIP_CHECK;
    inst_set1(addr16, bit_op_n);
}

# SET1 PSW.n
:SET1 PSW"."bit_op_n is SKIP_CHECK & opcode=0x71 & PSW; op_l=0xA & bit_op_n & mov1_sreg=0; opcode=0xFA {
    build SKIP_CHECK;
    inst_set1(PSW, bit_op_n);
}

# SET1 [HL].n
:SET1 AddrHL"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0x2 & bit_op_n & mov1_sreg=1 & AddrHL {
    build SKIP_CHECK;
    inst_set1(AddrHL, bit_op_n);
}

#
# Table 23/30
#

# CLR1 saddr.n
:CLR1 saddr"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0x3 & bit_op_n & mov1_sreg=0; saddr {
    build SKIP_CHECK;
    inst_clr1(saddr, bit_op_n);
}

# CLR1 sfr.n
:CLR1 sfrp"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0xB & bit_op_n & mov1_sreg=0; sfrp {
    build SKIP_CHECK;
    inst_clr1(sfrp, bit_op_n);
}

# CLR1 A.n
:CLR1 A"."bit_op_n is SKIP_CHECK & opcode=0x71 & A; op_l=0xB & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_clr1(A, bit_op_n);
}

#
# Table 24/30
#

# CLR1 !addr16.n
:CLR1 addr16"."bit_op_n is SKIP_CHECK & opcode=0x71; op_l=0x8 & bit_op_n & mov1_sreg=0; addr16 {
    build SKIP_CHECK;
    inst_clr1(addr16, bit_op_n);
}

# CLR1 PSW.n
:CLR1 PSW"."bit_op_n is SKIP_CHECK & opcode=0x71 & PSW; op_l=0xB & bit_op_n & mov1_sreg=0; opcode=0xFA {
    build SKIP_CHECK;
    inst_clr1(PSW, bit_op_n);
}

# CLR1 [HL].n
:CLR1 AddrHL"."bit_op_n is SKIP_CHECK & opcode=0x71 & AddrHL; op_l=0x3 & bit_op_n & mov1_sreg=1 {
    build SKIP_CHECK;
    inst_clr1(AddrHL, bit_op_n);
}

# SET1 CY
:SET1 "CY" is SKIP_CHECK & opcode=0x71; opcode=0x80 {
    build SKIP_CHECK;
    inst_set1($(CY), 0);
}

# CLR1 CY
:CLR1 "CY" is SKIP_CHECK & opcode=0x71; opcode=0x88 {
    build SKIP_CHECK;
    inst_clr1($(CY), 0);
}

# NOT1 CY
:NOT1 "CY" is SKIP_CHECK & opcode=0x71; opcode=0xC0 {
    build SKIP_CHECK;
    $(CY) = ~$(CY) & 0x1;
}

#
# Table 25/30
#

# CALL rp
:CALL CALL_RP is SKIP_CHECK & opcode=0x61; CALL_RP & op_l=0xA & mov1_sreg=1 {
    build SKIP_CHECK;
    call [CALL_RP];
}

# CALL $!addr20
:CALL jdisp16 is SKIP_CHECK & opcode=0xFE; jdisp16 {
    build SKIP_CHECK;
    call jdisp16;
}

# CALL !addr16
:CALL jaddr16 is SKIP_CHECK & opcode=0xFD; jaddr16 {
    build SKIP_CHECK;
    call jaddr16;
}

# CALL !!addr20
:CALL addr20 is SKIP_CHECK & opcode=0xFC; addr20 {
    build SKIP_CHECK;
    call addr20;
}

# CALLT [CALLT]
:CALLT CALLT_Entry is SKIP_CHECK & opcode=0x61; CALLT_Entry & op2_callt_hi & op2_callt_low & op2_b7=1 & op2_b23=0x1 {
    build SKIP_CHECK;
    call CALLT_Entry;
}

# BRK
:BRK is SKIP_CHECK & opcode=0x61; opcode=0xCC & brk_addr {
    build SKIP_CHECK;

    $(IE) = 0;
    PSW = PSW & 0x7f;

    PC = brk_addr;
    call brk_addr;
}

# RET
:RET is SKIP_CHECK & opcode=0xD7 & ret_addr {
    build SKIP_CHECK;
    return [ret_addr];
}

# RETI
:RETI (PC) is SKIP_CHECK & opcode=0x61; opcode=0xFC & PC {
    build SKIP_CHECK;
    return [PC];
}

# RETB
:RETB (PC) is SKIP_CHECK & opcode=0x61; opcode=0xEC & PC {
    build SKIP_CHECK;
    return [PC];
}

#
# Table 26/30
#

# PUSH PSW
:PUSH PSW is SKIP_CHECK & opcode=0x61 & PSW & sp; opcode=0xDD {
    build SKIP_CHECK;
    *:2 sp = zext(PSW);
    sp = sp - 2;
}

# PUSH rp
:PUSH DREG_WORD is SKIP_CHECK & op_h=0xC & DREG_WORD & rp_source=1 & sp {
    build SKIP_CHECK;
    *sp = DREG_WORD;
    sp = sp - 2;
}

# POP PSW
:POP PSW is SKIP_CHECK & opcode=0x61 & PSW & sp; opcode=0xCD {
    build SKIP_CHECK;
    local status:2 = *sp;
    sp = sp + 2;
    PSW = status:1;
}

# POP rp
:POP DREG_WORD is SKIP_CHECK & op_h=0xC & DREG_WORD & rp_source=0 & sp {
    build SKIP_CHECK;
    DREG_WORD = *sp;
    sp = sp + 2;
}

# MOVW SP, #word
:MOVW SP, u16 is SKIP_CHECK & opcode=0xCB & SP; opcode=0xF8; u16 {
    build SKIP_CHECK;
    SP = u16;
}

# MOVW SP, AX
:MOVW sp, AX is SKIP_CHECK & opcode=0xBE & sp & AX; opcode=0xF8 {
    build SKIP_CHECK;
    sp = segment(0:1, AX);
}

# MOVW AX, SP
:MOVW AX, SP is SKIP_CHECK & opcode=0xAE & SP & AX; opcode=0xF8 {
    build SKIP_CHECK;
    AX = SP;
}

# ADDW SP, #byte
:ADDW sp, u8 is SKIP_CHECK & opcode=0x10 & sp; u8 {
    build SKIP_CHECK;
    sp = sp + zext(u8);
}

# SUBW SP, #byte
:SUBW sp, u8 is SKIP_CHECK & opcode=0x20 & sp; u8 {
    build SKIP_CHECK;
    sp = sp - zext(u8);
}

# BR AX
:BR AX is SKIP_CHECK & opcode=0x61 & AX; opcode=0xCB {
    build SKIP_CHECK;
    local addr:3 = segment(CS, AX);
    PC = addr;
    goto [addr];
}

# BR $addr20
:BR jdisp8 is SKIP_CHECK & opcode=0xEF; jdisp8 {
    build SKIP_CHECK;
    branch(jdisp8);
}

# BR $!addr20
:BR jdisp16 is SKIP_CHECK & opcode=0xEE; jdisp16 {
    build SKIP_CHECK;
    branch(jdisp16);
}

# BR !addr16
:BR jaddr16 is SKIP_CHECK & opcode=0xED; jaddr16 {
    build SKIP_CHECK;
    branch(jaddr16);
}

# BR !!addr20
:BR addr20 is SKIP_CHECK & opcode=0xEC; addr20 {
    build SKIP_CHECK;
    branch(addr20);
}

# BC $addr20
# P-code doesn't allow for conditional register updates
# Only a conditional goto
:BC jdisp8 is SKIP_CHECK & opcode=0xDC; jdisp8 {
    build SKIP_CHECK;
    if ($(CY)) goto jdisp8;
    goto inst_next;
}

# BNC $addr20
:BNC jdisp8 is SKIP_CHECK & opcode=0xDE; jdisp8 {
    build SKIP_CHECK;
    if (!$(CY)) goto jdisp8;
}

# BZ $addr20
:BZ jdisp8 is SKIP_CHECK & opcode=0xDD; jdisp8 {
    build SKIP_CHECK;
    if ($(Z)) goto jdisp8;
}

# BNZ $addr20
:BNZ jdisp8 is SKIP_CHECK & opcode=0xDF; jdisp8 {
    build SKIP_CHECK;
    if (!$(Z)) goto jdisp8;
}

# BH $addr20
:BH jdisp8 is SKIP_CHECK & opcode=0x61; opcode=0xC3; jdisp8 {
    build SKIP_CHECK;
    if (!($(Z) | $(CY))) goto jdisp8;
}

# BNH $addr20
:BNH jdisp8 is SKIP_CHECK & opcode=0x61; opcode=0xD3; jdisp8 {
    build SKIP_CHECK;
    if ($(Z) | $(CY)) goto jdisp8;
}

# BT saddr.n, $addr20
:BT saddr"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31; op_l=0x2 & bit_op_n & mov1_sreg=0; saddr; jdisp8 {
    build SKIP_CHECK;
    inst_bt(saddr, bit_op_n, jdisp8);
}

# BT sfr.n, $addr20
:BT sfrp"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31; op_l=0x2 & bit_op_n & mov1_sreg=1; sfrp; jdisp8 {
    build SKIP_CHECK;
    inst_bt(sfrp, bit_op_n, jdisp8);
}

#
# Table 27/30
#

# BT A.n, $addr20
:BT A"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & A; op_l=0x3 & bit_op_n & mov1_sreg=0; jdisp8 {
    build SKIP_CHECK;
    inst_bt(A, bit_op_n, jdisp8);
}

# BT PSW.n, $addr20
:BT PSW"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & PSW; op_l=0x2 & bit_op_n & mov1_sreg=1; opcode=0xFA; jdisp8 {
    build SKIP_CHECK;
    inst_bt(PSW, bit_op_n, jdisp8);
}

# BT [HL].n, $addr20
:BT AddrHL"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & AddrHL; op_l=0x3 & bit_op_n & mov1_sreg=1; jdisp8 {
    build SKIP_CHECK;
    inst_bt(AddrHL, bit_op_n, jdisp8);
}

# BF saddr.n, $addr20
:BF saddr"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31; op_l=0x4 & bit_op_n & mov1_sreg=0; saddr; jdisp8 {
    build SKIP_CHECK;
    inst_bf(saddr, bit_op_n, jdisp8);
}

#
# Table 28/30
#

############################################
########## TODO THIS IS WRONG! #############
############################################
# BF sfr.n, $addr20
:BF sfrp"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31; op_l=0x4 & bit_op_n & mov1_sreg=1; sfrp; jdisp8 {
    build SKIP_CHECK;
    inst_bf(sfrp, bit_op_n, jdisp8);
}

# BF A.n, $addr20
:BF A"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & A; op_l=0x5 & bit_op_n & mov1_sreg=0; jdisp8 {
    build SKIP_CHECK;
    inst_bf(A, bit_op_n, jdisp8);
}

# BF PSW.n, $addr20
:BF PSW"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & PSW; op_l=0x4 & bit_op_n & mov1_sreg=1; opcode=0xFA; jdisp8 {
    build SKIP_CHECK;
    inst_bf(PSW, bit_op_n, jdisp8);
}

# BF [HL].n, $addr20
:BF AddrHL"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & AddrHL; op_l=0x5 & bit_op_n & mov1_sreg=1; jdisp8 {
    build SKIP_CHECK;
    inst_bf(AddrHL, bit_op_n, jdisp8);
}

#
# Table 29/30
#

# BTCLR saddr.n, $addr20
:BTCLR saddr"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31; op_l=0x0 & bit_op_n & mov1_sreg=0; saddr; jdisp8 {
    build SKIP_CHECK;
    inst_btclr(saddr, bit_op_n, jdisp8);
}

# BTCLR sfr.n, $addr20
:BTCLR sfrp"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31; op_l=0x0 & bit_op_n & mov1_sreg=1; sfrp; jdisp8 {
    build SKIP_CHECK;
    inst_btclr(sfrp, bit_op_n, jdisp8);
}

# BTCRL A.n, $addr20
:BTCLR A"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & A; op_l=0x1 & bit_op_n & mov1_sreg=0; jdisp8 {
    build SKIP_CHECK;
    inst_btclr(A, bit_op_n, jdisp8);
}

# BTCLR PSW.n, $addr20
:BTCLR PSW"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & PSW; op_l=0x0 & bit_op_n & mov1_sreg=1; opcode=0xFA; jdisp8 {
    build SKIP_CHECK;
    inst_btclr(PSW, bit_op_n, jdisp8);
}

# BTCRL [HL].n, $addr20
:BTCLR AddrHL"."bit_op_n, jdisp8 is SKIP_CHECK & opcode=0x31 & AddrHL; op_l=0x1 & bit_op_n & mov1_sreg=1; jdisp8 {
    build SKIP_CHECK;
    inst_btclr(AddrHL, bit_op_n, jdisp8);
}

#
# Table 30/30
#

# SKC
:SKC is opcode=0x61; opcode=0xC8 [ skip_mode=1; globalset(inst_next, skip_mode); ] { }

# SKNC
:SKNC is opcode=0x61; opcode=0xD8 [ skip_mode=2; globalset(inst_next, skip_mode); ] { }

# SKZ
:SKZ is opcode=0x61; opcode=0xE8 [ skip_mode=3; globalset(inst_next, skip_mode); ] { }

# SKNZ
:SKNZ is opcode=0x61; opcode=0xF8 [ skip_mode=4; globalset(inst_next, skip_mode); ] { }

# SKNH
:SKNH is opcode=0x61; opcode=0xF3 [ skip_mode=5; globalset(inst_next, skip_mode); ] { }

# SKH
:SKH is opcode=0x61; opcode=0xE3 [ skip_mode=6; globalset(inst_next, skip_mode); ] { }

# SEL RBn
:SEL rbs_op_n is opcode=0x61; op_l=0xF & rbs_op_n & mov1_sreg=1 [
    rsb = rbs_op_n;
    globalset(inst_next, rsb);
] {}

# NOP
:NOP is opcode=0x00 {}

# EI
:EI is SKIP_CHECK & opcode=0x71; opcode=0x7A; opcode=0xFA {
    build SKIP_CHECK;
    $(IE) = 1;
    enable_interrupts();
}

# DI
:DI is SKIP_CHECK & opcode=0x71; opcode=0x7B; opcode=0xFA {
    build SKIP_CHECK;
    $(IE) = 0;
    disable_interrupts();
}

# HALT
:HALT is SKIP_CHECK & opcode=0x61; opcode=0xED { build SKIP_CHECK; halt(); }

# STOP
:STOP is SKIP_CHECK & opcode=0x61; opcode=0xFD { build SKIP_CHECK; stop(); }

# PREFIX
:^instruction is es_prefix=0 & opcode=0x11; epsilon ... & instruction [ es_prefix=1; ] {
    build instruction;
}
